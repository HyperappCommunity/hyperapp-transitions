# Transition Helpers for Hyperapp / Picodom


Transitions, or more specifically transition-*animations* are animations that smooth out the appearance of your app as elements are added, changed and removed. Well designed transitions provide important cues to the user, and are essential for a good experience.

On the web, the favored approach is to use the CSS-transition property. Some javascript is often also needed, in order to apply the css properties with appropriate timing to achieve the desired effect.

This library provides function to help you design your app with beautiful, meaningful transitions without cluttering your code. Specifically for apps based on [Hyperapp](https://hyperapp.js.org) and [Picodom](https://github.com/picodom/picodom).

If you want to just dive straight in, have a look at these couple of live-editable examples on codepen:

- [Toasts](https://codepen.io/zaceno/pen/awRxaN)
- [15-puzzle](https://codepen.io/zaceno/pen/MoPLOj)
- [Carousel](https://codepen.io/zaceno/pen/awPbJG)

## Installation & Basic usage

### NPM

Install the package in your project

```
> npm install hyperapp-transitions
```

... then include it in your app, using `require` (or `import`, if using es6 modules).

```js
const transitions = require('hyperapp-transitions')
```

The imported object contains the helper methods described below.

### HTML

Include the following script tag in the `<head>...</head>` of your html page:

```html
<script src="https://unpkg.com/hyperapp-transitions@latest/dist/hyperapp-transitions.umd.js"></script>
```

This creates a `transitions` object in the global scope, through which you access the methods described below. 

### Basic usage

The library provides these *transition-creators*

- [change](#create)
- [move](#move)
- [enter](#enter)
- [leave](#leave)

Each shall be called with an object containing appropriate options, and will return a *transition-decorator*.

The transition-decorator is a function that is passed a vnode (generated by the `h` function in HyperApp/PicoDOM), and attaches handlers to its lifecycle methods (`oncreate`, `onupdate` and `onremove`), to effect the transition.

An example:

```jsx
const {enter} = require('hyperapp-transitions')

//define slideIn transition decorator
const slideIn = enter({
    name: 'slide',
    time: 300,
    easing: 'ease-in-out'
})

//Notification component that slides in:
const Notification = ({message}) => slideIn(
    <div class="notification">
        {message}
    </div>
)

```

Aditionally the library provides the `group` and `combine` utilities, described further below.

## `change`

The simples transition is the `change` Use it when your app will change css properties of an element (directly via style-property, or via classes), and you want those changes to transition smoothly.

Options:

- `easing`: the easing function to transition with  (default: `''` / linear)
- `time`: the duration of the transition in ms (default: `300`)

Example:
```jsx
const fader = transitions.change({easing: 'ease-in-out', time: 1500})

const MyFadingComponent = props => fader(<div>...</div>)
```

(Try a live example [here](https://codepen.io/zaceno/pen/zzmbye/))

## `enter`

Options:
- `easing`: the easing function to transition with  (default: `''` / linear)
- `time`: the duration of the transition in ms (default: `300`)
- `name`: the name of the transition (required)
- `delay`: time in ms to wait before starting transition (see [combine](#combine))

This transition-decorator is used to make elements appear gracefully, when they are created.

When elements are created under this decorator, they will start out having the `{name}-enter` class (where name is the name you defined in the options). It is up to you to define css for this class, to style the element into it's starting position.

Example:

*stylesheet*
```css
.slide-enter { transform: translateX(100%); }
```

*javascript*
```jsx
const {enter} = require('hyperapp-transitions')
const slideIn = enter({name: 'slide', time: 200})
...
notifications.map(txt => slideIn(<div class="notification">{txt}</div>))
...
```
(Try a live example [here](https://codepen.io/zaceno/pen/QgZQGW))

*Note: All nodes decorated with `enter` transitions need to be [keyed](https://github.com/hyperapp/hyperapp/blob/master/docs/keys.md)*

## `combine`

`combine(decorator, decorator, ...) -> decorator`

`combine` is a utility for combining transition-decorators.

Every transition-decorator returns the vnode it has just "decorated" (attached handlers to), allowing you to nest multiple decorators to build advanced effects.

```js
const decoratorA = enter({})
const decoratorB = change({})

const myAdvancedDecorator = vnode => decoratorA(decoratorB(vnode))
```

The `combine` utility is just a helper, to do the exact same thing, in the following way:

```js
const {combine, enter, change} = require('hyperapp-transitions')
const myAdvancedDecorator = combine(
    enter({}),
    change({})
)
```

### the `delay` option

`combine` lets you stack up multiple `enter`-decorators, but you may not want them all to kick of transitions at the same time. The delay property lets you hold of an individual transition for an amount of time.

The `combine` function together with the `delay` option, effectively allow you to define a "build-in-sequence" (as it is known in presentation softawre)

```js
const msgEntry = combine(
  enter({name: 'slide', time: 300}),
  enter({name: 'fade', time: 3000, delay: 200})
)
```

[Here](https://codepen.io/zaceno/pen/GEYxar) is a live example of combined enter-transitions

## `leave`

Options: 

- `easing`: the easing function to transition with  (default: `''` / linear)
- `time`: the duration of the transition in ms (default: `300`)
- `name`: the name of the transition (required)
- `delay`: time in ms to wait before starting transition
- `last`: boolean. Default `true`. Indicates if this is the last leave-decorator in a combination. 
- `ready`: delay in ms before registering position of element


`leave` transitions let elements that are removed from the dom exit in a graceful way. When an element is transitioning out, it gets the class `{name}-leave` applied to it (where `{name}` is the name given in the options). It is up to you to define this class in your stylesheet, to indicate the *final* state of the element, before it is removed.

*stylesheet*
```css
.pop-leave {
    transform: scale(2.0);
    opacity: 0;
}
```

*javascript*
```js
const popOut = transitions.leave({name:'pop', time: 150})
```

Try a live example [here](https://codepen.io/zaceno/pen/xryWyN)

### Combining leave-decorators

Much like `enter`, multiple leave-transitions can be combined into a build-out sequence (again using the `delay` option). But the default is for a single leave-transition to remove the element from the DOM once it has completed. So to achieve the desired effect, you must specify `last: false` on all those leave-decorators that will finish before the last one.

A live example of combined leave-decorators [here](https://codepen.io/zaceno/pen/weYNBN)

### Combining enter- and leave-decorators

With `combine` it is possible to create a single decorator that defines entry *and* exit transitions in a single decorator. For example you could define a *single* decorator for a notification widget that slides in and pops out.

However (for technical reasons) we need to capture the position of the element when it is created. When combined with an entry transition, this means we will capture the position of the element from the *starting point* of the transition. That will then become the starting point of the leave-transition when we remove it -- likely not what you want! 

To remedy this, we can use the `ready` option to tell the decorator when the last entry-transitions will be complete. It will wait for that amount of time, before recording the position of the element.

```js
const slideInPopOut = combine(
  enter({name: 'slide', time: 300}),
  leave({name: 'pop', time: 300, ready: 300})
)
```

A live example of combined enter- and leave-transitions [here](https://codepen.io/zaceno/pen/rwqZab)

*Note: All nodes decorated with `leave` transitions need to be [keyed](https://github.com/hyperapp/hyperapp/blob/master/docs/keys.md)*

## Deferred Options

Often, for `leave` and `enter` transitions in particular, you may not know how you would like to transition ("enter from the left? or the right?) until the user has interacted somehow. 

For this reason, all the transition-creators can be given a function that returns their options, instead of the options themselves. The function is called just before the transition starts.

```js

slideIn = enter(_ => {
    const name = 'slide-' + getDirection()
    return {name, time: 400}
})

```

This lets you implement "carousel" style navigation of images, for example.

[Here](https://codepen.io/zaceno/pen/awPbJG) is a live example.


## `move`

Options: 
- `easing`: the easing function to transition with  (default: `''` / linear)
- `time`: the duration of the transition in ms (default: `300`)

This transition creator is most naturally used together with `group`. When layout changes cause the element to be repositioned, move-decorators will cause the element to slide smoothly to its new position, rather than just "jump" into place.

For examples, see [`group`](#group)

*Note: All nodes decorated with `move` transitions need to be [keyed](https://github.com/hyperapp/hyperapp/blob/master/docs/keys.md)*

## `group`

`group(decorator) -> decorator`

`group` is another utility method for applying a decorator to children of an element rather than the decorated element itself.

A common pattern is to apply the same decorator to all siblings in a parent:

```jsx
const fader = change({/*...*/})
//...
<ToolBar>
    {fader(<EditButton />)}
    {fader(<SaveButton />)}
    {fader(<CloseButton />)}
</ToolBar>
```

Defining your decorator as a *group-decorator* with the `group` method, the following has the same effect:

```jsx

const groupFader = group(chage({/*...*/}))
//...
{groupFader(
    <ToolBar>
        <EditButton />
        <SaveButton />
        <CloseButton />
    </ToolBar>
)}
```

Note that although the group decorator is applied to the parent node, it only causes the children to be decorated. It does not actually touch the parents themselves.

### `group` and `move`

`move` fits naturally with group. Especially in cases when you have a parent, where the layout of children may be changing (like an image gallery being reordered).

For a practical, live example see this implementation of a [15 puzzle](https://codepen.io/zaceno/pen/MoPLOj)

### all together now...

By combining `move`, `leave` and `enter` decorators in a `group` you can make a quite elegant system for "toasts" (notifications that appear on screen in a row, and can be dismissed independently)

[Here](https://codepen.io/zaceno/pen/awRxaN) is a practical live example of just that. 
